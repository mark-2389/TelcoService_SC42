#!/usr/bin/env python3
import os
import re

def generate_header(db_name) -> str:
    """
    Generate the header to create the database, if the database doesn't exist.

    The header that generates the database is a string like
    CREATE DATABASE IF NOT EXISTS `db_name`;
    USE `db_name`;

    Parameters
    ----------
    db_name: str
        The name of the database.
    """

    s = ""
    s += "CREATE DATABASE IF NOT EXISTS `{}`;\n".format(db_name)
    s += "USE `telcoservice_db`;\n".format(db_name)
    return s


def generate_line(values):
    """
    Generate a the tuple that has to be inserted in the database.

    A tuple is a list of string values separated by commas. The tuple starts
    with an open parentheses and ends with a closed parentheses.
    ('value1', 'value2', 'value3', ...)

    Parameters
    ----------
    values: [str]
        A list of values that have to be in the tuple. The values are inserted
        in tuple in order. The list should contain at least one element.
    """

    assert len(values) > 0


    s = "('{}'".format(values[0])

    for e in values[1:]:
        s += ", '{}'".format(e)
    s += ")"

    return s


def generate_insert_command(table_name, list_of_values, keys=[]):
    """
    Generate an insertion command.

    If the keys parameter is an empty array, the insertion command is formatted
    as follows
    INSERT INTO `table_name`
    VALUES
        (value1, value2, value3),
        (value1, value2, value3),
        (value1, value2, value3);

    Otherwise if the keys parameter is non empty, the insertion command is
    formatted as follows
    INSERT INTO `table_name`(attribute1, attribute2, attribute3)
    VALUES
        (value1, value2, value3),
        (value1, value2, value3),
        (value1, value2, value3);

    Parameters:
    -----------
    table_name: str
        The name of the table in which the values have to be inserted.
    list_of_values: [[str]]
        The list of tuples that have to be inserted in the table. A tuple is a
        list of strings where each string represents a value of the tuple. All
        the tuples should have the same length.
    keys: [str]
        The list of the attibutes' names. If the list is empty then it's
        implicit that all the attributes are inserted. If the list is not empty
        it should be of the same length of the tuples passed in list_of_values.
    """

    assert len(list_of_values) > 0

    needs_keys = len(keys) > 0

    first_len = len(keys) if needs_keys else len(list_of_values[0])
    for e in list_of_values:
        assert len(e) == first_len

    s = "INSERT INTO `{}`\n".format(table_name)

    if needs_keys:
        s += "({}".format(keys[0])
        for k in keys[1:]:
            s += ", {}".format(k)
        s += ")"

    s += "VALUES \n{}".format(generate_line(list_of_values[0]))

    for v in list_of_values[1:]:
        s += ", \n{}".format(generate_line(v))

    s += ";"

    return s

def generate_insert(table_name, generator, number_of_iterations, keys=[]):
    """
    Generate an insert command.

    The function applies the generate function and generates an insert command
    using the values of the tuple returned by the generator. The function is
    applied number_of_iterations times.

    Parameters
    ----------
    table_name: str
        The name of the table in which the values have to be inserted.
    generator: function
        The function that is used to generate a tuple. The function must take a
        integer value as input and return a list of stings. The input value is
        an incremental id generated by the generate_insert function itself.
    number_of_iterations: int
        The number of times the generator function is called.
    keys: [str]
        The list of the attibutes' names. If the list is empty then it's
        implicit that all the attributes are inserted. If the list is not empty
        it should be of the same length of the tuples generated by the
        generator.

    Returns
    -------
    command: str
        The insert command.
    """
    res = []

    for i in range(number_of_iterations):
        val = generator(i)

        # if the value reutrned by the generator is null we want to return
        if val == None:
            return generate_insert_command(table_name, res, keys)

        # otherwise we append the value and continue the loop
        res.append(val)


    return generate_insert_command(table_name, res, keys)


def output_insert(filename, table_name, generator, number_of_iterations, keys=[], db_name=""):
    """
    Generate and output an insert command.

    Parameters
    ----------
    filename: str
        The name of the file to which the insert command has to be written.
    table_name: str
        The name of the table in which the values have to be inserted.
    generator: function
        The function that is used to generate a tuple. The function must take a
        integer value as input and return a list of stings. The input value is
        an incremental id generated by the generate_insert function itself.
    number_of_iterations: int
        The number of times the generator function is called.
    keys: [str]
        The list of the attibutes' names. If the list is empty then it's
        implicit that all the attributes are inserted. If the list is not empty
        it should be of the same length of the tuples generated by the
        generator. The default value is [].
    db_name: str
        The name of the database (the schema) in which the tuples have to be
        inserted. If an empty string is passed the command used to switch to the
        database is omitted. The default value is "".
    """

    filename = sanitise_filename(filename)

    with open(filename, 'w') as fp:
        str = "" if db_name == "" else generate_header(db_name)
        str += generate_insert(table_name, generator, number_of_iterations, keys)
        fp.write(str)



def sanitise_filename(filename):
    """
    Generate a new filename if the filename passed as argument aleady exists.

    If the filename passed as parameter already exists the function tries to
    generate a new valid filename. Initially the function appends a (1) at the
    end of the filename (e.g. output/client.sql -> output/client(1).sql).
    If the number at the end is already present, it is incremented
    (e.g. output/client(1).sql -> output/client(2).sql). 

    Parameters
    ----------
    filename: str
        The name of a file with its path.

    Returns
    -------
    A non existing filename.
    """
    while os.path.isfile(filename):
        print(filename)
        file = filename.rsplit('/', 1) # path, file
        path = file[0]
        file = file[1]

        no_extension = file.split('.')
        extension = no_extension[1]
        no_extension = no_extension[0]

        numbers = re.findall(r"\([0-9]+\)", no_extension)

        if len(numbers) == 0:
            filename = path + "/" + no_extension + "(1)." + extension
        else:
            version = numbers[-1].replace("(", "")
            version = version.replace(")", "")
            name_no_version = re.split(r"\([0-9]+\)", no_extension)[0]
            filename = path + "/" + name_no_version + '({})'.format(int(version) + 1) + '.' + extension


    return filename
